- 既提升了运行效率，又减少了代码体积
- Tree Shaking 又被称为 Scope Hoisting 作用域提升

### Webpack Tree Shaking 与 Babel
- Tree Shaking 前提是 ES Modules
- 由 Webpack 打包的代码必须使用 ESM
- 为了转换代码中的 ECMAScript 新特性而使用 babel-loader ，就有可能导致 ESM => CommonJS，这取决我们有没有使用转换 ESM 的插件


### Webpack 代码分割

代码分包
- 所有代码最终都被打包到一起，bundle 体积过大
- 并不是每个模块在启动时都是必要的
- 模块打包是必要的，但是应用越来越大之后，需要进行分包，按需加载
- 有两种方式：多入口打包；ESM 动态导入


#### 多入口打包
- 常用于多页应用程序
- 一个页面对应一个打包入口
- 公共部分单独提取

#### 动态导入
- 按需加载，需要用到某个模块时，再加载这个模块
- 可以极大地节省带宽和流量
- 无需配置任何地方，只需要按照 ESM 动态导入的方式去导入模块，webpack 内部会自动处理分包和按需加载
- 使用单页应用开发框架（React/Vue），在项目中的路由映射组件就可以通过动态导入实现按需加载

#### Webpack 魔法注释
- 使用魔法注释可以为动态导入最终打包出来的文件命名
- 命名相同的模块最终会被打包到一起

#### Webpack 输出文件名 Hash
- 一般我们部署前端资源文件时，都会采用服务器的静态资源缓存
- 开启缓存的问题：缓存时间过短-效果不明显，缓存过期时间较长-应用发生了更新重新部署后客户端因为缓存得不到更新
- 解决上面问题，建议生产模式下，文件名使用 Hash，文件名不同也就是新的请求，解决了缓存的问题，服务器可以将缓存过期时间设置足够长

三种 Hash 方式
- hash: 整个项目级别的，项目中任意一个地方改动，重新打包之后的 hash 值都会改变
- chunkhash: chunk 级别的，同一路的打包 chunkhash 都是相同的
- contenthash: 文件级别的hash，根据文件内容生成的hash值，不同的文件就有不同的值

解决缓存问题的最佳 hash 方式 [contenthash:8]